<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Auto Image Compressor</title>
    <link rel="icon" href="https://shawkui.github.io/images/favicon-96x96.png?v=M44lzPylqQ" type="image/png">

    <style>
        :root {
            --bg-color: #f5f5f5;
            --text-color: #333;
            --accent-color: #0080ff;
            --accent-hover: #0066cc;
            --accent-active: #004d99;
            --border-color: #ccc;
            --success-color: #28a745;
        }

        body {
            background: var(--bg-color);
            font-family: monospace;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            color: var(--text-color);
        }

        header, footer {
            background: var(--text-color);
            color: white;
            padding: 15px;
            text-align: center;
            position: relative;
        }

        header h1 { margin: 0; font-size: 1.8em; }

        #lang-toggle {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            padding: 5px 12px;
            background: transparent;
            color: white;
            border: 1px solid white;
            border-radius: 4px;
            cursor: pointer;
            font-family: monospace;
        }
        #lang-toggle:hover { background: rgba(255,255,255,0.2); }

        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px 20px;
        }

        .tool-card {
            background: white;
            width: 100%;
            max-width: 900px;
            padding: 30px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }

        .config-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px dashed var(--border-color);
        }

        .input-group { display: flex; flex-direction: column; gap: 8px; }
        .input-group label { font-weight: bold; font-size: 0.85em; }

        input[type="number"], select, input[type="file"] {
            padding: 8px;
            font-family: monospace;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            outline: none;
        }

        .btn {
            background: var(--accent-color);
            color: white;
            cursor: pointer;
            font-size: 1.1em;
            font-family: monospace;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            transition: background 0.2s ease-in-out;
            width: 100%;
        }
        .btn:hover { background: var(--accent-hover); }
        .btn:disabled { background: #ccc; cursor: not-allowed; }

        #report {
            margin-top: 30px;
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }
        #report th { text-align: left; border-bottom: 2px solid var(--text-color); padding: 10px; }
        #report td { padding: 10px; border-bottom: 1px solid #eee; }

        .status-badge {
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.85em;
        }
        .status-working { background: #fff3cd; color: #856404; }
        .status-done { background: #d4edda; color: #155724; }
        .status-skip { background: #e2e3e5; color: #383d41; }

        .download-link { color: var(--accent-color); text-decoration: none; font-weight: bold; }
        #batch-download-btn { margin-top: 20px; background: var(--success-color); display: none; }

        .instructions {
            margin-top: 40px;
            padding: 25px;
            background: #fafafa;
            border: 1px solid #eee;
            border-radius: 8px;
            font-size: 0.9em;
        }
        .instructions h3 { margin-top: 0; color: var(--accent-color); border-bottom: 1px solid #ddd; padding-bottom: 5px; }
        .instructions ul { padding-left: 20px; line-height: 1.7; }
        .instructions li { margin-bottom: 12px; }
        .instructions code { background: #eee; padding: 2px 4px; border-radius: 3px; }

        .note { color: #666; font-size: 0.85em; border-left: 3px solid var(--accent-color); padding-left: 10px; margin-top: 15px; }

        footer a { color: white; text-decoration: underline; }
    </style>
</head>

<body>
    <header>
        <h1 data-en="Image Compressor" data-zh="图片自动压缩器">Image Compressor</h1>
        <button id="lang-toggle">中文</button>
    </header>

    <main>
        <div class="tool-card">
            <div class="config-section">
                <div class="input-group">
                    <label data-en="Target Size (KB)" data-zh="目标大小 (KB)">Target Size (KB)</label>
                    <input type="number" id="targetSize" value="512" min="1">
                </div>
                <div class="input-group">
                    <label data-en="Max Iterations" data-zh="最大迭代次数">Max Iterations</label>
                    <input type="number" id="maxIter" value="10" min="1" max="30" title="Higher = more precise file size">
                </div>
                <div class="input-group">
                    <label data-en="Strategy" data-zh="压缩策略">Strategy</label>
                    <select id="strategyMode">
                        <option value="auto" data-en="Smart Heuristic" data-zh="智能启发式">Smart Heuristic</option>
                        <option value="manual" data-en="Manual Start" data-zh="手动起始值">Manual Start</option>
                    </select>
                </div>
                <div class="input-group" id="manualQualityGroup" style="display:none;">
                    <label data-en="Initial Quality" data-zh="初始质量">Initial Quality</label>
                    <input type="number" id="manualQuality" value="0.95" step="0.05" min="0.1" max="1.0">
                </div>
                <div class="input-group">
                    <label data-en="Upload Images" data-zh="上传图片">Upload Images</label>
                    <input type="file" id="fileInput" accept="image/jpeg,image/png" multiple>
                </div>
            </div>

            <button id="processBtn" class="btn" data-en="Compress Images" data-zh="开始压缩图片">Compress Images</button>

            <table id="report" style="display: none;">
                <thead>
                    <tr>
                        <th data-en="Filename" data-zh="文件名">Filename</th>
                        <th data-en="Original" data-zh="原始大小">Original</th>
                        <th data-en="Result" data-zh="压缩后">Result</th>
                        <th data-en="Status" data-zh="状态">Status</th>
                        <th data-en="Action" data-zh="操作">Action</th>
                    </tr>
                </thead>
                <tbody id="fileList"></tbody>
            </table>

            <button id="batch-download-btn" class="btn" onclick="downloadAll()" data-en="Download All Results" data-zh="下载全部压缩结果">Download All Results</button>

            <div class="instructions">
                <h3 data-en="User Instructions" data-zh="使用说明">User Instructions</h3>
                <div id="instruction-content">
                    <div class="lang-en">
                        <ul>
                            <li><strong>1. Selection:</strong> Choose one or multiple JPG/PNG images. Files are processed locally and never uploaded to any server.</li>
                            <li><strong>2. Set Target:</strong> Enter your maximum file size in <code>KB</code>. The algorithm targets a result as close to this number as possible without exceeding it.</li>
                            <li><strong>3. Max Iterations:</strong>
                                <br>• <code>8-10</code>: Standard speed. Good for general use.
                                <br>• <code>15-20</code>: High precision. Best for hitting exact targets (e.g., getting a 6MB file down to exactly 511KB).
                            </li>
                            <li><strong>4. Strategy:</strong>
                                <br>• <code>Smart Heuristic</code>: Automatically calculates the starting quality based on the original-to-target ratio to save time and detail.
                                <br>• <code>Manual Start</code>: Forces the search to begin at a specific quality level.
                                <br>• <strong>Suggestion:</strong> Set quality <code>&lt; 1.0</code>. A higher value (e.g., 0.99) offers better precision but requires more <code>Iterations</code> to converge.
                            </li>
                            <li><strong>5. How it Works:</strong> The tool uses a <strong>Double Binary Search</strong>. It first adjusts image quality. If the target size is still not met even at low quality, it performs a second search to find the optimal dimension scale.</li>
                        </ul>
                    </div>
                    <div class="lang-zh" style="display:none;">
                        <ul>
                            <li><strong>1. 选择图片:</strong> 选择一个或多个 JPG/PNG 图片。文件在本地处理，绝不会上传到服务器。</li>
                            <li><strong>2. 设定目标:</strong> 输入最大文件大小（单位 <code>KB</code>）。算法会尽可能接近此数值且不超过它。</li>
                            <li><strong>3. 最大迭代次数:</strong>
                                <br>• <code>8-10</code>: 标准速度，适合日常使用。
                                <br>• <code>15-20</code>: 高精度，适合追求极度精准的文件大小。
                            </li>
                            <li><strong>4. 压缩策略:</strong>
                                <br>• <code>智能启发式</code>: 根据原图比例自动计算起始质量，平衡速度与画质。
                                <br>• <code>手动起始值</code>: 强制从特定的质量等级开始搜索。
                                <br>• <strong>建议:</strong> 设定值应 <code>&lt; 1.0</code>。数值越大精度越高，但需要配合更高的 <code>迭代次数</code> 才能完成搜索。
                            </li>
                            <li><strong>5. 技术原理:</strong> 采用 <strong>双重二分查找算法</strong>。首先调整图片质量；如果最低质量仍超标，则进行第二次搜索以寻找最佳缩放比例。</li>
                        </ul>
                    </div>
                </div>
                <div class="note">
                    <strong data-en="Privacy & Tech:" data-zh="隐私与技术：">Privacy & Tech:</strong> 
                    <span data-en="100% Client-Side. Your data privacy is guaranteed as the processing happens entirely within your browser's memory using the Canvas API." 
                          data-zh="100% 客户端处理。通过 Canvas API 在浏览器内存中完成，保证您的数据隐私。">100% Client-Side. Your data privacy is guaranteed...</span>
                </div>
            </div>
        </div>
    </main>

    <footer>
        <p data-en="Image Compressor by Shaokui Wei" data-zh="图片自动压缩器 - 魏少奎">Image Compressor by Shaokui Wei</p>
        <p><a href="https://shawkui.github.io/">https://shawkui.github.io</a>, 2024</p>
    </footer>

    <script>
        // 保持原本的逻辑脚本
        const fileInput = document.getElementById('fileInput');
        const targetSizeInput = document.getElementById('targetSize');
        const maxIterInput = document.getElementById('maxIter');
        const strategyMode = document.getElementById('strategyMode');
        const manualQualityGroup = document.getElementById('manualQualityGroup');
        const processBtn = document.getElementById('processBtn');
        const reportTable = document.getElementById('report');
        const fileList = document.getElementById('fileList');
        const batchBtn = document.getElementById('batch-download-btn');
        const langToggle = document.getElementById('lang-toggle');

        let downloadQueue = [];
        let currLang = 'en';

        const i18n = {
            en: { working: "Working...", done: "Compressed", original: "Original Kept", error: "Error", download: "Download", alertSelect: "Please select images first." },
            zh: { working: "处理中...", done: "压缩完成", original: "保留原图", error: "错误", download: "下载", alertSelect: "请先选择图片。" }
        };

        langToggle.onclick = () => {
            currLang = currLang === 'en' ? 'zh' : 'en';
            langToggle.innerText = currLang === 'en' ? '中文' : 'English';
            document.querySelectorAll('[data-en]').forEach(el => {
                el.innerText = el.getAttribute(`data-${currLang}`);
            });
            document.querySelector('.lang-en').style.display = currLang === 'en' ? 'block' : 'none';
            document.querySelector('.lang-zh').style.display = currLang === 'zh' ? 'block' : 'none';
        };

        strategyMode.onchange = () => {
            manualQualityGroup.style.display = strategyMode.value === 'manual' ? 'flex' : 'none';
        };

        processBtn.onclick = async () => {
            const files = Array.from(fileInput.files);
            const targetKB = parseFloat(targetSizeInput.value);
            const iterations = parseInt(maxIterInput.value) || 10;
            if (!files.length) return alert(i18n[currLang].alertSelect);

            fileList.innerHTML = '';
            reportTable.style.display = 'table';
            batchBtn.style.display = 'none';
            downloadQueue = [];
            processBtn.disabled = true;

            for (const file of files) {
                const row = createRow(file);
                fileList.appendChild(row);
                const originalKB = file.size / 1024;

                if (originalKB <= targetKB) {
                    const url = URL.createObjectURL(file);
                    updateRow(row, url, `${originalKB.toFixed(1)} KB`, i18n[currLang].original, 'status-skip', file.name);
                    downloadQueue.push({url, name: file.name});
                } else {
                    try {
                        const blob = await preciseCompress(file, targetKB, originalKB, iterations);
                        const url = URL.createObjectURL(blob);
                        const finalKB = (blob.size / 1024).toFixed(1);
                        const newName = `compressed_${Math.round(finalKB)}kb_${file.name}`;
                        updateRow(row, url, `${finalKB} KB`, i18n[currLang].done, 'status-done', newName);
                        downloadQueue.push({url, name: newName});
                    } catch (e) {
                        console.error(e);
                        updateRow(row, null, '-', i18n[currLang].error, 'status-skip', '');
                    }
                }
            }
            processBtn.disabled = false;
            if (downloadQueue.length > 0) batchBtn.style.display = 'block';
        };

        async function preciseCompress(file, targetKB, originalKB, iterations) {
            const bitmap = await createImageBitmap(file);
            let startQ = 0.98;

            if (strategyMode.value === 'manual') {
                startQ = parseFloat(document.getElementById('manualQuality').value) || 0.95;
            } else {
                const ratio = targetKB / originalKB;
                if (ratio > 0.9) startQ = 0.98;
                else if (ratio > 0.7) startQ = 0.95;
                else if (ratio < 0.2) startQ = 0.6;
            }

            let bestBlob = null;
            let lowQ = 0.01, highQ = startQ;
            for (let i = 0; i < iterations; i++) {
                let midQ = (lowQ + highQ) / 2;
                let blob = await canvasToBlob(bitmap, midQ, 1.0);
                if (blob.size / 1024 <= targetKB) {
                    bestBlob = blob;
                    lowQ = midQ; 
                } else {
                    highQ = midQ;
                }
            }

            if (!bestBlob) {
                let lowS = 0.05, highS = 1.0;
                for (let i = 0; i < iterations; i++) {
                    let midS = (lowS + highS) / 2;
                    let blob = await canvasToBlob(bitmap, 0.7, midS); 
                    if (blob.size / 1024 <= targetKB) {
                        bestBlob = blob;
                        lowS = midS; 
                    } else {
                        highS = midS;
                    }
                }
            }
            return bestBlob || await canvasToBlob(bitmap, 0.1, 0.1);
        }

        function canvasToBlob(bitmap, quality, scale) {
            return new Promise(resolve => {
                const canvas = document.createElement('canvas');
                canvas.width = Math.max(1, Math.floor(bitmap.width * scale));
                canvas.height = Math.max(1, Math.floor(bitmap.height * scale));
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
                canvas.toBlob(b => resolve(b), 'image/jpeg', quality);
            });
        }

        function createRow(file) {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${file.name}</td>
                <td>${(file.size / 1024).toFixed(1)} KB</td>
                <td class="res-size">-</td>
                <td><span class="status-badge status-working">${i18n[currLang].working}</span></td>
                <td class="res-action">-</td>
            `;
            return tr;
        }

        function updateRow(row, url, sizeText, statusText, statusClass, downloadName) {
            row.querySelector('.res-size').innerText = sizeText;
            const badge = row.querySelector('.status-badge');
            badge.innerText = statusText;
            badge.className = 'status-badge ' + statusClass;
            if (url) {
                const a = document.createElement('a');
                a.href = url;
                a.download = downloadName;
                a.innerText = i18n[currLang].download;
                a.className = 'download-link';
                row.querySelector('.res-action').innerHTML = '';
                row.querySelector('.res-action').appendChild(a);
            }
        }

        function downloadAll() {
            downloadQueue.forEach((item, i) => {
                setTimeout(() => {
                    const a = document.createElement('a');
                    a.href = item.url;
                    a.download = item.name;
                    a.click();
                }, i * 350);
            });
        }
    </script>
</body>

</html>
